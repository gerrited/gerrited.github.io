<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gerrit.codes</title><link>https://gerrit.codes/</link><description>Recent content on gerrit.codes</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Wed, 05 Jun 2024 19:58:58 +0200</lastBuildDate><atom:link href="https://gerrit.codes/index.xml" rel="self" type="application/rss+xml"/><item><title>PowerShell Functions als Alias nutzen</title><link>https://gerrit.codes/posts/2024/06/powershell-functions-als-alias-nutzen/</link><pubDate>Wed, 05 Jun 2024 19:58:58 +0200</pubDate><guid>https://gerrit.codes/posts/2024/06/powershell-functions-als-alias-nutzen/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>Im Alltag nutze ich unter Windows gerne das neue Terminal. Ich habe es wie im Blog Post von &lt;a href="https://www.hanselman.com/blog/my-ultimate-powershell-prompt-with-oh-my-posh-and-the-windows-terminal">Scott Hanselman&lt;/a> beschrieben, etwas angepasst.&lt;/p>
&lt;p>Was mir bei PowerShell noch fehlte, war eine Möglichkeit, eigene Aliase und Abkürzungen für mehrere, immer aufeinander folgende Befehle, zu erstellen. Im folgenden möchte ich kurz vorstellen, wie ich mein Windows Terminal auf einfache Art, noch produktiver gemacht habe.&lt;/p>
&lt;h2 id="vorgehen">Vorgehen&lt;/h2>
&lt;p>Durch den folgenden Befehl lässt sich in PowerShell die Beschreibung des eigenen PowerShell Profils (quasi dem Äquivalent zu .bash_profile oder .bashrc) öffnen.&lt;/p></description></item><item><title>Internet Monitoring mit K8s und Grafana</title><link>https://gerrit.codes/posts/2023/10/internet-monitoring-mit-kubernetes-und-grafana/</link><pubDate>Tue, 03 Oct 2023 20:50:58 +0200</pubDate><guid>https://gerrit.codes/posts/2023/10/internet-monitoring-mit-kubernetes-und-grafana/</guid><description>&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>Nach dem Wechsel auf Glasfaser, hatte ich zwischendurch Ruckler beim Streaming. Das WLAN selbst war gut erreichbar. Das konnte ich mittels einer WLAN Analyzer App kontrollieren.&lt;/p>
&lt;p>Die Daten zur Internetnutzung waren nicht ausreichend, um dort ein Problem feststellen zu können. Entsprechend habe ich selbst an einer Lösung gearbeitet, um die Internetgeschwindigkeit regelmäßig zu messen und sie visuell aufzubereiten.&lt;/p>
&lt;h2 id="anforderungen">Anforderungen&lt;/h2>
&lt;ul>
&lt;li>Die Messung soll auf dem &lt;a href="https://gerrit.codes/posts/2022/01/raspberry-pi-cluster-mit-k3s/">Raspberry Pi Kubernetes Cluster&lt;/a> stattfinden, weil es 24/7 läuft.&lt;/li>
&lt;li>Für die Auswertung und Anzeige soll Grafana genutzt werden, weil ich damit bereits länger arbeite.&lt;/li>
&lt;li>Ich wollte mich nicht selbst um die dauerhafte Speicherung kümmern. Prima, dass die Grafana Cloud einen umfangreichen Funktionsumfang kostenlos anbietet.&lt;/li>
&lt;/ul>
&lt;h2 id="umsetzung">Umsetzung&lt;/h2>
&lt;p>Ich bin relativ schnell auf &lt;a href="https://github.com/jeanralphaviles/prometheus_speedtest">prometheus_speedtest&lt;/a> gestoßen. Dabei handelt es sich um ein Python Package, welches Speedtest.net Ergebnisse als Prometheus Metrics Endpoints anbietet. Auch ein Container Image und passende K8s Manifests waren schon vorhanden.&lt;/p></description></item><item><title>CoreDNS meldet i/o timeout - Lösung 42</title><link>https://gerrit.codes/posts/2023/09/kubernetes-coredns-io-timeout/</link><pubDate>Sun, 17 Sep 2023 11:19:05 +0200</pubDate><guid>https://gerrit.codes/posts/2023/09/kubernetes-coredns-io-timeout/</guid><description>&lt;p>Seit Kurzem nutzt die Infrastruktur des &lt;a href="https://gerrit.codes/posts/2022/01/raspberry-pi-cluster-mit-k3s/">Raspberry Pi Kubernetes Clusters&lt;/a> den Travel Router SFT1200 von GL.iNET. Dieser kann Internetzugriff via LAN, WLAN, Tethering und USB Modem für andere Geräte via LAN und WLAN bereitstellen. Um den Ersatz der SD-Karten der bisherigen Geräte zu vereinfachen, habe ich im Router statische DHCP-Einträge für die MAC-Adressen hinterlegt. Dabei dachte ich, es gut wäre, wenn ich statt des Standardnetzes (Class C), mal etwas anderes nutze, damit ich die Netze intern gut unterscheiden kann. Ich habe mich für Class A (konkret 10.42.42.0/24) entschieden und die Konfiguration der Nodes entsprechend geändert.&lt;/p></description></item><item><title>Unit-Tests für IoC Container</title><link>https://gerrit.codes/posts/2022/02/unit-tests-fuer-ioc-container/</link><pubDate>Sat, 12 Feb 2022 11:02:32 +0100</pubDate><guid>https://gerrit.codes/posts/2022/02/unit-tests-fuer-ioc-container/</guid><description>&lt;img
sizes="(min-width: 35em) 720px, 100vw"
srcset='
/img/006-title_hu410616865176714455.png 500w
, /img/006-title_hu14860504790620854606.png 800w
, /img/006-title_hu9920598084828111685.png 1200w
'
src="https://gerrit.codes/img/006-title.png"
alt="">
&lt;h2 id="das-problem">Das Problem&lt;/h2>
&lt;p>Wenn für eine Anwendung &lt;a href="https://martinfowler.com/articles/injection.html">Dependency Injection&lt;/a> (DI) genutzt wird und ein Inversion of Control (IoC) Container wie Autofac zum Einsatz kommt, kann es schnell passieren, dass nicht alle benötigten Komponenten registriert werden. Die Abhängigkeiten einer Klasse werden z.B. als Interface in den Constructor injiziert und fortan genutzt. Während der Entwicklung fällt dann nicht auf, dass die Abhängigkeit nicht aufgelöst werden kann, aber sobald die Anwendung gestartet und genutzt wird, kommt es zu Fehlermeldungen, die oft zum Absturz der Anwendung führen.&lt;/p></description></item><item><title>Lokales K8s mit Cloudflare Tunnel im Internet verfügbar</title><link>https://gerrit.codes/posts/2022/01/k8s-tunnel-cloudflare/</link><pubDate>Sun, 30 Jan 2022 15:24:11 +0100</pubDate><guid>https://gerrit.codes/posts/2022/01/k8s-tunnel-cloudflare/</guid><description>&lt;img
sizes="(min-width: 35em) 720px, 100vw"
srcset='
/img/k3s-cloudflared_hu4700487157590287570.png 500w
, /img/k3s-cloudflared_hu11318030510492112810.png 800w
, /img/k3s-cloudflared_hu940242105855685870.png 1200w
'
src="https://gerrit.codes/img/k3s-cloudflared.png"
alt="">
&lt;h2 id="vorbereitungen">Vorbereitungen&lt;/h2>
&lt;p>Cloudflare bietet seit 2021 (siehe &lt;a href="https://blog.cloudflare.com/tunnel-for-everyone/">A Boring Announcement: Free Tunnels for Everyone&lt;/a>) kostenlose Tunnels an. Damit können lokale Websites im Internet verfügbar gemacht werden. Benötigt wird nur eine Domain, bei der Cloudflare als Nameserver hinterlegt ist. Wie das genau geht, ist unter &lt;a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide">&amp;ldquo;Set up your first tunnel&amp;rdquo;&lt;/a> beschrieben.&lt;/p>
&lt;h2 id="tunnel-für-services-im-kubernetes-cluster">Tunnel für Services im Kubernetes Cluster&lt;/h2>
&lt;p>Erstellte Tunnel können auch für Services in einem Kubernetes Cluster genutzt werden. Eine Anleitung mit Beispiel gibt es in &lt;a href="https://github.com/gerrited/argo-tunnel-examples/tree/master/named-tunnel-k8s">meinem Fork von cloudflare/argo-tunnel-examples&lt;/a>. Im dortigen Kubernetes Manifest &lt;a href="https://github.com/gerrited/argo-tunnel-examples/blob/master/named-tunnel-k8s/cloudflared.yaml">&amp;ldquo;cloudflared.yml&amp;rdquo;&lt;/a> habe ich, im Vergleich zum Original, das Container Image von &lt;a href="https://hub.docker.com/r/cloudflare/cloudflared/tags">cloudflare/cloudflared&lt;/a> auf &lt;a href="https://hub.docker.com/r/erisamoe/cloudflared/tags">erisamoe/cloudflared&lt;/a> geändert, damit das Deployment auch auf arm64 (also z.B. auf einem Raspberry Pi und somit auch im &lt;a href="https://gerrit.codes/posts/2022/01/raspberry-pi-cluster-mit-k3s/">Raspberry Pi Kubernetes Cluster&lt;/a>) und nicht nur auf amd64 funktioniert.&lt;/p></description></item><item><title>Bloggen mit Hugo und GitHub Pages</title><link>https://gerrit.codes/posts/2022/01/bloggen-mit-hugo-und-github-pages/</link><pubDate>Sat, 15 Jan 2022 22:02:31 +0100</pubDate><guid>https://gerrit.codes/posts/2022/01/bloggen-mit-hugo-und-github-pages/</guid><description>&lt;h2 id="plattform">Plattform&lt;/h2>
&lt;img
sizes="(min-width: 35em) 720px, 100vw"
srcset='
/img/hugo-website_hu15766528688600786367.png 500w
, /img/hugo-website_hu16415905539642139967.png 800w
, /img/hugo-website_hu4492444193662151785.png 1200w
'
src="https://gerrit.codes/img/hugo-website.png"
alt="">
&lt;p>Eigentlich habe ich mich recht schnell für &lt;a href="https://gohugo.io/" title="Hugo">Hugo&lt;/a> als Framework für das neue Blog entschieden. Davor hatte ich damit keinen Kontakt, aber Dokumentation und Community machten einen guten Eindruck auf mich. Außerdem waren andere Blogs und Websites, die auf Hugo basierte, simple, schnell und modern.&lt;/p>
&lt;h2 id="theme">Theme&lt;/h2>
&lt;p>Das Theme &lt;a href="https://github.com/rhazdon/hugo-theme-hello-friend-ng" title="Hugo Theme hello-friend-ng">hello-friend-ng&lt;/a> habe ich (einfach und etwas langweilig) unter den Themes auf der &lt;a href="https://themes.gohugo.io/">offiziellen Hugo Website&lt;/a> gefunden. Der Entwickler &lt;a href="https://github.com/rhazdon">Djordje Atlialp&lt;/a> nutzt es selbst für seinen Blog und ich bin bisher zufrieden mit dem Look und den integrierten Funktionen.&lt;/p></description></item><item><title>K8s Deployment visualisieren</title><link>https://gerrit.codes/posts/2022/01/kubernetes-deployment-visualisieren/</link><pubDate>Mon, 10 Jan 2022 07:24:32 +0100</pubDate><guid>https://gerrit.codes/posts/2022/01/kubernetes-deployment-visualisieren/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>Um Deployments eines Kubernetes Clusters zu visualisieren, habe ich mir &lt;a href="https://learn.pimoroni.com/article/getting-started-with-blinkt">Pimoroni Blinkt&lt;/a> LED Strips gekauft und sie auf die GPIO-Slots der RPi des Clusters gesteckt.&lt;/p>
&lt;h2 id="demo">Demo&lt;/h2>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/U6AsAn490-4?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Durch &lt;a href="https://github.com/gerrited/blinkt-k8s-controller">blinkt-controller&lt;/a> wird ein &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">Daemonset&lt;/a> erstellt, welches auf die Labels &lt;code>blinkt&lt;/code> und &lt;code>blinktColor&lt;/code> von Pods reagiert. Damit die LEDs angesteuert werden können, laufen die Pods als cluster-admin. Weiteres unter &lt;a href="https://github.com/gerrited/blinkt-k8s-controller#how-it-works">&amp;ldquo;How it works&amp;rdquo;&lt;/a> auf GitHub.&lt;/p></description></item><item><title>Raspberry Pi Cluster mit k3s</title><link>https://gerrit.codes/posts/2022/01/raspberry-pi-cluster-mit-k3s/</link><pubDate>Sat, 08 Jan 2022 18:37:38 +0100</pubDate><guid>https://gerrit.codes/posts/2022/01/raspberry-pi-cluster-mit-k3s/</guid><description>&lt;p>Um mich auf einer Art Spielwiese mit Kubernetes auseinandersetzen zu können, habe ich Anfang 2020 folgendes bestellt:&lt;/p>
&lt;ul>
&lt;li>4 x Raspberry Pi 4 B (4x 1,5 GHz, 2 GB RAM)&lt;/li>
&lt;li>4 x SanDisk Ultra MicroSDHC 32GB&lt;/li>
&lt;li>RPI CASE TR 19 (transparentes Gehäuse für mehrere Raspberry Pi)&lt;/li>
&lt;li>TP-Link 5-Port Gigabit Switch&lt;/li>
&lt;li>Anker USB-Ladegerät PowerPort+, 5 V, 2400 mA, 5 USB-Ports&lt;/li>
&lt;li>diverse USB und LAN Kabel&lt;/li>
&lt;/ul>
&lt;p>Weitere Produktinformationen können bei den üblichen Shops gefunden werden. Der Gesamtpreis belief sich auf ca. 300€.&lt;/p></description></item><item><title>Happy New Year and Hello World!</title><link>https://gerrit.codes/posts/2022/01/happy-new-year-and-hello-world/</link><pubDate>Sat, 01 Jan 2022 14:00:00 +0100</pubDate><guid>https://gerrit.codes/posts/2022/01/happy-new-year-and-hello-world/</guid><description>&lt;p>
&lt;img
style='width: 12em; float:right'
sizes="(min-width: 35em) 720px, 100vw"
srcset='
/img/hello-world_hu4959803478289390969.jpg 500w
, /img/hello-world_hu17587583509987323130.jpg 800w
, /img/hello-world_hu7659904935582682163.jpg 1200w
'
src="https://gerrit.codes/img/hello-world.jpg"
alt="">
Pünktlich zum Jahreswechsel startet dieses Blog. Hier will ich über kleine Projekte schreiben und es damit meinem zukünftigen Ich einfacher machen, sie wieder zu verstehen.&lt;/p>
&lt;p>Da es beim Jahreswechsel 2021/2022 weder (meiner Meinung nach auch zum Glück) ausartende Feuerwerke noch eine große Feier gab, muss ein Foto vom neuen Macbook Pro 2021, welches das Macbook Air 2013 abgelöst hat, als Ersatz herhalten. Irgendwie auch passend.&lt;/p></description></item><item><title>About</title><link>https://gerrit.codes/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gerrit.codes/about/</guid><description>&lt;img
style='float: right; border-radius: 10em; margin: 1em; width: 10em;'
sizes="(min-width: 35em) 720px, 100vw"
srcset='
/img/portrait_hu4926941568515797863.jpg 500w
, /img/portrait_hu8495131383580967562.jpg 800w
, /img/portrait_hu836523063750575047.jpg 1200w
'
src="https://gerrit.codes/img/portrait.jpg"
alt="Gerrit Edzards">
&lt;h3 id="moin">Moin!&lt;/h3>
&lt;p>Mein Name ist Gerrit und ich lebe in Oldenburg. Seit über 10 Jahren entwickle ich Software mit .NET und beschäftige mich aktuell vor allem mit Kubernetes und Azure.&lt;/p>
&lt;p>Beruflich arbeite ich überwiegend unter Windows und privat nutze ich meistens ein MacBook. Neben Azure DevOps und Jenkins Pipelines, administriere ich auch weitere Systeme (z.B. icinga, Grafana und SonarQube) und habe dadurch auch regelmäßig Kontakt mit Linux und VMware. Für die Systemwartung setze ich gerne Tools wie ansible und terraform ein.&lt;/p></description></item></channel></rss>